// Generated by CoffeeScript 1.10.0
(function() {
  "Entity\n\nAn entity is a thing in the game world.\nThe player ship, rocks, shots, etc are all entities.";
  var A, Beam, C, E, Entity, H, MovingEntity,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  E = {};

  _first.offer('entity', E);

  A = _first.request('assets');

  C = _first.request('config');

  H = _first.request('helper');

  Entity = (function() {
    Entity.prototype.img = null;

    Entity.prototype.r_img = 0;

    function Entity(pos) {
      this.pos = pos.copyPos();
      this.alive = true;
    }

    Entity.prototype.setImg = function(img) {
      this.img = img;
      return this.r_img = this.img.canvas.width / 2;
    };

    Entity.prototype.getImg = function() {
      return this.img;
    };

    Entity.prototype.update = function(dt) {
      if (!this.alive) {
        return false;
      }
      return true;
    };

    Entity.prototype.draw = function(ctx) {
      var i, len, pt, ref, results, row;
      ref = this.setClones();
      results = [];
      for (i = 0, len = ref.length; i < len; i++) {
        row = ref[i];
        results.push((function() {
          var j, len1, results1;
          results1 = [];
          for (j = 0, len1 = row.length; j < len1; j++) {
            pt = row[j];
            if (H.onScreenEntity(pt, this.r_img)) {
              results1.push(H.drawEntity(ctx, this.getImg(), pt));
            } else {
              results1.push(void 0);
            }
          }
          return results1;
        }).call(this));
      }
      return results;
    };

    Entity.prototype.centerCamera = function() {
      return H.updateCamera(this.pos);
    };

    Entity.prototype.setClones = function() {
      return H.setClones(this.pos);
    };

    return Entity;

  })();

  E.Entity = Entity;

  Beam = (function() {
    Beam.prototype.wid = null;

    Beam.prototype.color = null;

    function Beam(line) {
      this.line = line;
      this.alive = true;
    }

    Beam.prototype.getWidth = function() {
      return this.wid;
    };

    Beam.prototype.getColor = function() {
      return this.color;
    };

    Beam.prototype.update = function(dt) {
      if (!this.alive) {
        return false;
      }
      return true;
    };

    Beam.prototype.draw = function(ctx) {
      return H.drawLineEntity(ctx, this.line, this.getWidth(), this.getColor());
    };

    return Beam;

  })();

  E.Beam = Beam;

  MovingEntity = (function(superClass) {
    extend(MovingEntity, superClass);

    MovingEntity.prototype.acc = 0;

    MovingEntity.prototype.r = 0;

    MovingEntity.prototype.m = 0;

    MovingEntity.prototype.thrust = false;

    MovingEntity.prototype.drag = false;

    function MovingEntity(pos, a1, vel, va) {
      this.a = a1;
      this.va = va;
      MovingEntity.__super__.constructor.call(this, pos);
      this.vel = vel.copyPos();
    }

    MovingEntity.prototype.update = function(dt) {
      this.pos.transXY(this.vel.x * dt, -this.vel.y * dt);
      this.a += this.va * dt;
      if (this.thrust) {
        this.vel.transPolar(this.acc, this.a);
      }
      if (this.drag) {
        this.vel.scale(1 - this.drag * dt);
      }
      this.wrap();
      return MovingEntity.__super__.update.call(this, dt);
    };

    MovingEntity.prototype.setAcc = function(acc) {
      this.acc = acc;
      if (this.acc && this.acc !== 0) {
        return this.thrust = true;
      } else {
        return this.thrust = false;
      }
    };

    MovingEntity.prototype.setR = function(r1) {
      this.r = r1;
    };

    MovingEntity.prototype.setM = function(m) {
      this.m = m;
    };

    MovingEntity.prototype.draw = function(ctx) {
      var i, len, pt, ref, results, row;
      ref = this.setClones();
      results = [];
      for (i = 0, len = ref.length; i < len; i++) {
        row = ref[i];
        results.push((function() {
          var j, len1, results1;
          results1 = [];
          for (j = 0, len1 = row.length; j < len1; j++) {
            pt = row[j];
            if (H.onScreenEntity(pt, this.r_img)) {
              if (this.watch) {
                console.log(pt);
              }
              results1.push(H.drawEntity(ctx, this.getImg(), pt, this.a));
            } else {
              results1.push(void 0);
            }
          }
          return results1;
        }).call(this));
      }
      return results;
    };

    MovingEntity.prototype.wrap = function() {
      if (this.pos.x < -C.tileSize / 2) {
        this.pos.x += C.tileSize;
      }
      if (this.pos.x > C.tileSize / 2) {
        this.pos.x -= C.tileSize;
      }
      if (this.pos.y < -C.tileSize / 2) {
        this.pos.y += C.tileSize;
      }
      if (this.pos.y > C.tileSize / 2) {
        return this.pos.y -= C.tileSize;
      }
    };

    MovingEntity.prototype.collide = function(obj) {
      return this.pos.collide(obj.pos, this.r + obj.r);
    };

    MovingEntity.prototype.bounce = function(obj) {
      this.bouncePos(obj);
      return this.bounceVel(obj);
    };

    MovingEntity.prototype.bouncePos = function(obj) {
      var a, r;
      a = obj.pos.getFaceAngle(this.pos);
      r = obj.r + this.r;
      H.pt.setPos(obj.pos);
      return this.pos.setPos(H.pt.transPolar(r, a));
    };

    MovingEntity.prototype.bounceVel = function(obj) {
      var ma, mb, vxf, vyf;
      ma = (this.m - obj.m) / (this.m + obj.m);
      mb = obj.m * 2 / (this.m + obj.m);
      vxf = ma * this.vel.x + mb * obj.vel.x;
      vyf = ma * this.vel.y + mb * obj.vel.y;
      return this.vel.setXY(vxf, vyf);
    };

    return MovingEntity;

  })(Entity);

  E.MovingEntity = MovingEntity;

  E.BgTile = function() {
    var bgTile;
    bgTile = new Entity(H.origin);
    bgTile.setImg(A.img.bg.tile);
    return bgTile;
  };

  E.PlayerShip = function() {
    var playerShip;
    playerShip = new MovingEntity(H.origin, 0, H.origin, 0);
    playerShip.setImg(A.img.ship.raymine);
    playerShip.setR(playerShip.r_img);
    playerShip.setM(C.shipMass);
    playerShip.drag = C.shipDrag;
    return playerShip;
  };

  E.LuckyBase = function() {
    var luckyBase;
    luckyBase = new MovingEntity(H.origin, 0, H.origin, 0);
    luckyBase.setImg(A.img.ship.baselucky);
    luckyBase.setR(luckyBase.r_img);
    luckyBase.setM(C.baseMass);
    return luckyBase;
  };

  E.BuildBase = function() {
    var buildBase, p;
    p = C.tileSize / 2 - 20;
    buildBase = new MovingEntity(H.pt.setXY(p, p), 0, H.origin, 0);
    buildBase.setImg(A.img.ship.basebuild);
    buildBase.setR(buildBase.r_img);
    buildBase.setM(C.baseMass);
    return buildBase;
  };

  E.RandRock = function() {
    var p, rock;
    p = C.tileSize / 2;
    rock = new MovingEntity(H.pt1.randomInBox(-p, p, -p, p), 0, H.pt2.randomInCircle(C.rockVel), 0);
    rock.setImg(A.img.space.r0);
    rock.setR(rock.r_img);
    rock.setM(C.rockMass);
    return rock;
  };

  E.spawnRock = function(dt) {
    return Math.random() < C.rockSpawnChance * dt;
  };

}).call(this);

// Generated by CoffeeScript 1.10.0
(function() {
  "Entity\n\nAn entity is a thing in the game world.\nThe player ship, rocks, shots, etc are all entities.";
  var A, Beam, C, E, Entity, H, MovingEntity,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  E = {};

  _first.offer('entity', E);

  A = _first.request('assets');

  C = _first.request('config');

  H = _first.request('helper');

  Entity = (function() {
    Entity.prototype.img = null;

    function Entity(pos) {
      this.pos = pos.copyPos();
      this.alive = true;
    }

    Entity.prototype.setImg = function(img) {
      this.img = img;
      return this.r_img = this.img.canvas.width / 2;
    };

    Entity.prototype.getImg = function() {
      return this.img;
    };

    Entity.prototype.update = function(dt) {
      if (!this.alive) {
        return false;
      }
      return true;
    };

    Entity.prototype.draw = function(ctx) {
      var i, len, pt, ref, results, row;
      ref = this.setClones();
      results = [];
      for (i = 0, len = ref.length; i < len; i++) {
        row = ref[i];
        results.push((function() {
          var j, len1, results1;
          results1 = [];
          for (j = 0, len1 = row.length; j < len1; j++) {
            pt = row[j];
            if (H.onScreenEntity(pt, this.r_img)) {
              results1.push(H.drawEntity(ctx, this.getImg(), pt));
            } else {
              results1.push(void 0);
            }
          }
          return results1;
        }).call(this));
      }
      return results;
    };

    Entity.prototype.centerCamera = function() {
      return H.updateCamera(this.pos);
    };

    Entity.prototype.setClones = function() {
      return H.setClones(this.pos);
    };

    return Entity;

  })();

  E.Entity = Entity;

  Beam = (function() {
    Beam.prototype.wid = null;

    Beam.prototype.color = null;

    function Beam(line) {
      this.line = line;
      this.alive = true;
    }

    Beam.prototype.getWidth = function() {
      return this.wid;
    };

    Beam.prototype.getColor = function() {
      return this.color;
    };

    Beam.prototype.update = function(dt) {
      if (!this.alive) {
        return false;
      }
      return true;
    };

    Beam.prototype.draw = function(ctx) {
      return H.drawLineEntity(ctx, this.line, this.getWidth(), this.getColor());
    };

    return Beam;

  })();

  E.Beam = Beam;

  MovingEntity = (function(superClass) {
    extend(MovingEntity, superClass);

    function MovingEntity(pos, a, vel, va) {
      this.a = a;
      this.va = va;
      MovingEntity.__super__.constructor.call(this, pos);
      this.vel = vel.copyPos();
    }

    MovingEntity.prototype.update = function(dt) {
      this.pos.transXY(this.vel.x * dt, -this.vel.y * dt);
      this.a += this.va * dt;
      if (this.thrust) {
        this.vel.transPolar(this.acc, this.a);
      }
      if (this.drag) {
        this.vel.scale(1 - this.drag * dt);
      }
      this.wrap();
      return MovingEntity.__super__.update.call(this, dt);
    };

    MovingEntity.prototype.setAcc = function(acc) {
      this.acc = acc;
      if (this.acc && this.acc !== 0) {
        return this.thrust = true;
      } else {
        return this.thrust = false;
      }
    };

    MovingEntity.prototype.draw = function(ctx) {
      var i, len, pt, ref, results, row;
      ref = this.setClones();
      results = [];
      for (i = 0, len = ref.length; i < len; i++) {
        row = ref[i];
        results.push((function() {
          var j, len1, results1;
          results1 = [];
          for (j = 0, len1 = row.length; j < len1; j++) {
            pt = row[j];
            if (H.onScreenEntity(pt, this.r_img)) {
              if (this.watch) {
                console.log(pt);
              }
              results1.push(H.drawEntity(ctx, this.getImg(), pt, this.a));
            } else {
              results1.push(void 0);
            }
          }
          return results1;
        }).call(this));
      }
      return results;
    };

    MovingEntity.prototype.wrap = function() {
      if (this.pos.x < -C.tileSize / 2) {
        this.pos.x += C.tileSize;
      }
      if (this.pos.x > C.tileSize / 2) {
        this.pos.x -= C.tileSize;
      }
      if (this.pos.y < -C.tileSize / 2) {
        this.pos.y += C.tileSize;
      }
      if (this.pos.y > C.tileSize / 2) {
        return this.pos.y -= C.tileSize;
      }
    };

    return MovingEntity;

  })(Entity);

  E.MovingEntity = MovingEntity;

  E.BgTile = function() {
    var bgTile;
    bgTile = new Entity(H.origin);
    bgTile.setImg(A.img.bg.tile);
    return bgTile;
  };

  E.PlayerShip = function() {
    var playerShip;
    playerShip = new MovingEntity(H.origin, 0, H.origin, 0);
    playerShip.setImg(A.img.ship.dropciv);
    playerShip.drag = C.shipDrag;
    return playerShip;
  };

  E.LuckyBase = function() {
    var luckyBase;
    luckyBase = new MovingEntity(H.origin, 0, H.origin, 0);
    luckyBase.setImg(A.img.ship.baselucky);
    return luckyBase;
  };

  E.BuildBase = function() {
    var buildBase;
    buildBase = new MovingEntity(H.pt.setXY(1450, 1450), 0, H.origin, 0);
    buildBase.setImg(A.img.ship.basebuild);
    buildBase.watch = true;
    return buildBase;
  };

}).call(this);

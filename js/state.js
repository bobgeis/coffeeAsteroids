// Generated by CoffeeScript 1.10.0
(function() {
  "State\n\nVarious game states/modes/screens/views/etc.\neg: Preloader Screen, Splash Screen, Play Screen, etc.";
  var A, C, H, M, S, State, U, changeState, currentState, eng, getCtx, getModel, getPlayer, getState;

  S = {};

  _first.offer('state', S);

  A = _first.request('assets');

  C = _first.request('config');

  H = _first.request('helper');

  M = _first.request('model');

  U = _first.request('hud');

  eng = null;

  S.initStates = function(engine) {
    eng = engine;
    return eng.changeState(S.preload);
  };

  changeState = function(state) {
    return eng.changeState(state);
  };

  getPlayer = function() {
    return eng.player;
  };

  getModel = function() {
    return eng.model;
  };

  getState = function() {
    return eng.state;
  };

  getCtx = function() {
    return eng.ctx;
  };

  State = (function() {
    function State() {
      return;
    }

    State.prototype.enter = function() {
      return console.log("enter");
    };

    State.prototype.draw = function(ctx) {
      return console.log("draw " + ctx);
    };

    State.prototype.update = function(dt) {
      return false;
    };

    State.prototype.input = function(type, data) {
      return console.log("input: " + type + " " + data);
    };

    State.prototype.exit = function() {
      return console.log("exit");
    };

    return State;

  })();

  currentState = null;

  S.setState = function(state) {
    if (currentState) {
      currentState.exit();
    }
    state.enter();
    return currentState = state;
  };

  S.updateState = function(dt) {
    if (currentState) {
      return currentState.update(dt);
    }
  };

  S.preload = {
    enter: function() {
      console.log("enter preload");
      return A.loadAllImgs();
    },
    draw: function(ctx) {
      ctx.fillStyle = "#000000";
      ctx.fillRect(0, 0, ctx.canvas.width, ctx.canvas.height);
      return H.drawText(ctx, "Loading", ctx.canvas.width / 2, ctx.canvas.height / 2, 30);
    },
    update: function(dt) {
      if (A.loadingFinished()) {
        A.afterLoad();
        return changeState(S.splash);
      }
    },
    input: function(type, data) {},
    exit: function() {
      return console.log("exit preload");
    }
  };

  S.splash = {
    y: 0,
    enter: function() {
      return console.log("enter splash");
    },
    draw: function(ctx) {
      var a, img;
      ctx.fillStyle = "#000000";
      ctx.fillRect(0, 0, ctx.canvas.width, ctx.canvas.height);
      H.drawImg(ctx, A.img.bg.tile, ctx.canvas.width / 2, ctx.canvas.height / 2 + this.y);
      H.drawImg(ctx, A.img.bg.tile, ctx.canvas.width / 2, ctx.canvas.height / 2 + this.y - C.tileSize);
      img = A.img.ship.rayciv;
      a = H.HALFPI;
      H.drawImg(ctx, img, ctx.canvas.width / 2, ctx.canvas.height / 2, a);
      return H.drawText(ctx, "Press [Enter] to start.", ctx.canvas.width / 2, ctx.canvas.height / 2 + 130, 15);
    },
    update: function(dt) {
      this.y = this.y + dt / 1.5;
      return this.y = this.y % C.tileSize;
    },
    input: function(type, data) {
      if (type === "keydown") {
        console.log(data.code);
        if (data.code === "Enter") {
          S.play.init();
          return changeState(S.play);
        }
      }
    },
    exit: function() {
      return console.log("exit splash");
    }
  };

  S.play = {
    model: null,
    enter: function() {
      return console.log("enter play");
    },
    init: function() {
      return this.model = new M.Model();
    },
    draw: function(ctx) {
      ctx.fillStyle = "#000000";
      ctx.fillRect(0, 0, ctx.canvas.width, ctx.canvas.height);
      if (this.model) {
        return this.model.draw(ctx);
      }
    },
    update: function(dt) {
      var newMode;
      if (this.model) {
        this.model.update(dt);
        if (this.model.changeMode) {
          newMode = this.model.changeMode;
          this.model.changeMode = 0;
          if (newMode === 1) {
            return changeState(S.gameOver);
          } else if (newMode === 2) {
            return changeState(S.dockMode);
          }
        }
      }
    },
    input: function(type, data) {
      if (type === "keydown") {
        if (data.code === "ArrowLeft") {
          return this.model.command(1);
        } else if (data.code === "ArrowRight") {
          return this.model.command(2);
        } else if (data.code === "ArrowUp") {
          return this.model.command(3);
        } else if (data.code === "ArrowDown") {
          return this.model.command(4);
        } else if (data.code === "Space") {
          return this.model.command(6);
        } else if (data.code === "Enter") {
          return this.model.command(7);
        } else if (data.code === "KeyL") {
          return this.model.command(98);
        } else if (data.code === "KeyK") {
          return this.model.command(99);
        }
      } else if (type === "keyup") {
        if (data.code === "ArrowLeft") {
          return this.model.command(11);
        } else if (data.code === "ArrowRight") {
          return this.model.command(11);
        } else if (data.code === "ArrowUp") {
          return this.model.command(13);
        } else if (data.code === "ArrowDown") {
          return this.model.command(13);
        } else if (data.code === "Space") {
          return this.model.command(5);
        } else if (data.code === "Enter") {
          return this.model.command(17);
        }
      }
    },
    exit: function() {
      return console.log("exit play");
    }
  };

  S.gameOver = {
    enter: function() {
      return console.log("enter gameOver");
    },
    draw: function(ctx) {
      S.play.draw(ctx);
      H.drawText(ctx, "You have died. So it goes.", ctx.canvas.width / 2, ctx.canvas.height / 2 - 200, 30);
      return H.drawText(ctx, "Press [Escape] to go to the intro.", ctx.canvas.width / 2, ctx.canvas.height / 2 + 130, 15);
    },
    update: function(dt) {
      return S.play.model.update(dt);
    },
    input: function(type, data) {
      if (type === "keydown") {
        if (data.code === "Escape") {
          return changeState(S.splash);
        }
      }
    },
    exit: function() {
      return console.log("exit gameOver");
    }
  };

  S.dockMode = {
    enter: function() {
      console.log("enter dockMode");
      return this.msg = U.dockMessageWindow();
    },
    draw: function(ctx) {
      S.play.draw(ctx);
      this.msg.draw(ctx);
      H.drawText(ctx, "You are docked.", ctx.canvas.width / 2, ctx.canvas.height / 2 - 200, 30);
      return H.drawText(ctx, "Press [Escape] to return.", ctx.canvas.width / 2, ctx.canvas.height / 2 + 330, 15);
    },
    update: function(dt) {},
    input: function(type, data) {
      if (type === "keydown") {
        if (data.code === "Escape") {
          return changeState(S.play);
        }
      }
    },
    exit: function() {
      return console.log("exit dockMode");
    }
  };

}).call(this);

// Generated by CoffeeScript 1.10.0
(function() {
  "State\n\nVarious game states/modes/screens/views/etc.\neg: Preloader Screen, Splash Screen, Play Screen, etc.";
  var A, C, H, M, Q, S, State, U, blankHiScore, changeState, currentState, eng, getCtx, getModel, getPlayer, getState;

  S = {};

  _first.offer('state', S);

  A = _first.request('assets');

  C = _first.request('config');

  H = _first.request('helper');

  M = _first.request('model');

  Q = _first.request('quest');

  U = _first.request('hud');

  eng = null;

  S.initStates = function(engine) {
    eng = engine;
    return eng.changeState(S.preload);
  };

  changeState = function(state) {
    return eng.changeState(state);
  };

  getPlayer = function() {
    return eng.player;
  };

  getModel = function() {
    return eng.model;
  };

  getState = function() {
    return eng.state;
  };

  getCtx = function() {
    return eng.ctx;
  };

  State = (function() {
    function State() {
      return;
    }

    State.prototype.enter = function() {
      return console.log("enter");
    };

    State.prototype.draw = function(ctx) {
      return console.log("draw " + ctx);
    };

    State.prototype.update = function(dt) {
      return false;
    };

    State.prototype.input = function(type, data) {
      return console.log("input: " + type + " " + data);
    };

    State.prototype.exit = function() {
      return console.log("exit");
    };

    return State;

  })();

  currentState = null;

  S.setState = function(state) {
    if (currentState) {
      currentState.exit();
    }
    state.enter();
    return currentState = state;
  };

  S.updateState = function(dt) {
    if (currentState) {
      return currentState.update(dt);
    }
  };

  S.preload = {
    enter: function() {
      console.log("enter preload");
      return A.loadAllImgs();
    },
    draw: function(ctx) {
      ctx.fillStyle = "#000000";
      ctx.fillRect(0, 0, ctx.canvas.width, ctx.canvas.height);
      return H.drawText(ctx, "Loading", ctx.canvas.width / 2, ctx.canvas.height / 2, 30);
    },
    update: function(dt) {
      if (A.loadingFinished()) {
        A.afterLoad();
        return changeState(S.splash);
      }
    },
    input: function(type, data) {},
    exit: function() {
      return console.log("exit preload");
    }
  };

  S.splash = {
    y: 0,
    enter: function() {
      return console.log("enter splash");
    },
    draw: function(ctx) {
      var a, img;
      ctx.fillStyle = "#000000";
      ctx.fillRect(0, 0, ctx.canvas.width, ctx.canvas.height);
      H.drawImg(ctx, A.img.bg.tile, ctx.canvas.width / 2, ctx.canvas.height / 2 + this.y);
      H.drawImg(ctx, A.img.bg.tile, ctx.canvas.width / 2, ctx.canvas.height / 2 + this.y - C.tileSize);
      img = A.img.ship.rayciv;
      a = H.HALFPI;
      H.drawImg(ctx, img, ctx.canvas.width / 2, ctx.canvas.height / 2, a);
      H.drawText(ctx, "Press [Enter] to start.", ctx.canvas.width / 2, ctx.canvas.height / 2 + 150, 15);
      H.drawText(ctx, "Game controls:", ctx.canvas.width / 2, ctx.canvas.height / 2 + 200, 12);
      H.drawText(ctx, "Arrow Keys to move.", ctx.canvas.width / 2, ctx.canvas.height / 2 + 212, 10);
      H.drawText(ctx, "Press [Space] to fire.", ctx.canvas.width / 2, ctx.canvas.height / 2 + 224, 10);
      return H.drawText(ctx, "Hold [Enter] to dock.", ctx.canvas.width / 2, ctx.canvas.height / 2 + 236, 10);
    },
    update: function(dt) {
      this.y = this.y + dt / 1.5;
      return this.y = this.y % C.tileSize;
    },
    input: function(type, data) {
      if (type === "keydown") {
        console.log(data.code);
        if (data.code === "Enter") {
          S.play.init();
          return changeState(S.play);
        }
      }
    },
    exit: function() {
      return console.log("exit splash");
    }
  };

  S.play = {
    model: null,
    enter: function() {
      return console.log("enter play");
    },
    init: function() {
      return this.model = new M.Model();
    },
    draw: function(ctx) {
      ctx.fillStyle = "#000000";
      ctx.fillRect(0, 0, ctx.canvas.width, ctx.canvas.height);
      if (this.model) {
        return this.model.draw(ctx);
      }
    },
    update: function(dt) {
      if (this.model) {
        this.model.update(dt);
        return this.maybeChangeMode();
      }
    },
    input: function(type, data) {
      if (type === "keydown") {
        if (data.code === "ArrowLeft") {
          return this.model.command(1);
        } else if (data.code === "ArrowRight") {
          return this.model.command(2);
        } else if (data.code === "ArrowUp") {
          return this.model.command(3);
        } else if (data.code === "ArrowDown") {
          return this.model.command(4);
        } else if (data.code === "Space") {
          return this.model.command(6);
        } else if (data.code === "Enter") {
          return this.model.command(7);
        } else if (data.code === "KeyL") {
          return this.model.command(98);
        } else if (data.code === "KeyK") {
          return this.model.command(99);
        }
      } else if (type === "keyup") {
        if (data.code === "ArrowLeft") {
          return this.model.command(11);
        } else if (data.code === "ArrowRight") {
          return this.model.command(11);
        } else if (data.code === "ArrowUp") {
          return this.model.command(13);
        } else if (data.code === "ArrowDown") {
          return this.model.command(13);
        } else if (data.code === "Space") {
          return this.model.command(5);
        } else if (data.code === "Enter") {
          return this.model.command(17);
        }
      }
    },
    exit: function() {
      return console.log("exit play");
    },
    maybeChangeMode: function() {
      var newMode;
      if (this.model.changeMode) {
        newMode = this.model.changeMode;
        this.model.changeMode = 0;
        if (newMode === 1) {
          return changeState(S.gameOver);
        } else if (newMode === 2) {
          changeState(S.dockMode);
          return S.dockMode.setQuest(this.model.quest);
        }
      }
    }
  };

  S.gameOver = {
    enter: function() {
      console.log("enter gameOver");
      return this.updateHiScores();
    },
    draw: function(ctx) {
      S.play.draw(ctx);
      H.drawText(ctx, "You have died. So it goes.", ctx.canvas.width / 2, ctx.canvas.height / 2 - 200, 30);
      return H.drawText(ctx, "Press [Escape] to go to the intro.", ctx.canvas.width / 2, ctx.canvas.height / 2 + 250, 15);
    },
    update: function(dt) {
      return S.play.model.update(dt);
    },
    input: function(type, data) {
      if (type === "keydown") {
        if (data.code === "Escape") {
          return changeState(S.splash);
        }
      }
    },
    exit: function() {
      return console.log("exit gameOver");
    },
    updateHiScores: function() {
      var i, len, oldHiScore, ref, score, type;
      oldHiScore = JSON.parse(localStorage.getItem('HiScore')) || blankHiScore;
      score = S.play.model.getScore();
      this.newHiScore = {};
      ref = ['ship', 'crystal', 'mousepod', 'lifepod'];
      for (i = 0, len = ref.length; i < len; i++) {
        type = ref[i];
        this.newHiScore[type] = Math.max(score[type], oldHiScore[type]);
      }
      localStorage.setItem('HiScore', JSON.stringify(this.newHiScore));
      return console.log(this.newHiScore);
    }
  };

  blankHiScore = {
    ship: 0,
    crystal: 0,
    lifepod: 0,
    mousepod: 0
  };

  S.dockMode = {
    enter: function() {
      console.log("enter dockMode");
      return this.msg = U.dockMessageWindow;
    },
    setQuest: function(quest) {
      return this.msg.setQuest(quest);
    },
    draw: function(ctx) {
      S.play.draw(ctx);
      this.msg.draw(ctx);
      H.drawText(ctx, "Your ship is docked and refueled.", ctx.canvas.width / 2, ctx.canvas.height / 2 - 200, 20);
      return H.drawText(ctx, "Press [Escape] to launch.", ctx.canvas.width / 2, ctx.canvas.height / 2 + 250, 20);
    },
    update: function(dt) {},
    input: function(type, data) {
      if (type === "keydown") {
        if (data.code === "Escape") {
          return changeState(S.play);
        }
      }
    },
    exit: function() {
      return console.log("exit dockMode");
    }
  };

}).call(this);
